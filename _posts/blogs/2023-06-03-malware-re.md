---
layout: post
permalink: /blogs/:title/
title:  "Back to Basics: Malware Reverse Engineering"
---

In 2022, I achieved OSCP and OSEP, both of which delved heavily in the penetration testing domain. In 2023, I've decided to learn something new, by tackling another domain which seems more challenging and daunting. Yep, as the title of this blog post has revealed, I've enrolled myself in a Malware Reverse Engineering course by [Zero2Automated](https://courses.zero2auto.com/), which was recommended by a renown vulnerability researcher, [Spaceraccoon](https://spaceraccoon.dev/), after I personally reached out to him for advice. If somehow you are reading this, thank you once again :)!  


## Why Malware Reverse Engineering?
Despite obtaining some of the more heavily coveted certifications in the penetration testing domain, I still feel like a script kiddie. So, in 2023, I was hoping to learn something that is more low-leveled. Malware RE and debugging seems to fit this description. Naturally, anything that is considered to be "low-leveled" has a much steeper learning curve. I started the course in May and at the time of writing (June), I am still in the midst of the course and only at Chapter 3, out of the 10 chapters available in the course!

## Purpose of this Blog
This brings me to the purpose of writing this blog! In this blog, I would like to share about what I have learnt so far, and hopefully this helps with learning and memory retention. Additionally, this post serves as a reference, where I can come back to in the future if I ever want to revisit my fundamentals. 

## Methodology
When presented with malware, we can analyse it in two ways:<br>
1) Static Analysis - This can be done using tools such as PE-Studio, strings, IDA<br>
2) Dynamic Analysis - Usually done using a debugger. However, one can also run the malware and observe its interaction with the OS.<br>

The typical malware sequence is as follows:<br>
Initial Stager (1st Loader, usually in common file types such as PDF, word doc) -> Loader (2nd Loader, usually an executable) -> Final Payload -> Additional Plugin (DLLs)

### PE-Studio
With PE-Studio (or other similar PE analyser tools), we are looking for a few things. These information allows us to identify if the sample is packed or not. A custom packed sample usually requires manual depacking which can be time-consuming.<br>
1) Entropy. Entropy describes the frequency of recurring bytes. The higher the entropy, the lower the amount of recurring bytes, which usually indicates that the data is encrypted (or packed)<br>
2) Description. Sometimes the description may give away information about the packer used for the specific malware sample.<br>
2) Libraries (& Imports). The lack of imports or an abundance of unusual imports in the binary can indicate that the program is packed. <br>

## IDA (Disassembler)
With IDA, we are primarily looking for the flow of code in the sample. The flow of code can sometimes tell us the encryption or decryption sub-routines which are commonly used in malwares. Additionally, if the sample is packed, we also need to identify the sequence of code where the packed sample is allocating memory space for the unpacked executable. Looking at JMP or CALL instructions might yield faster results. 

## x32/x64dbg (Debugger)
With a debugger, we are essentially running the malware. But, we have the option to stop and analyse each line of code, and manipulate any data if needed. Since most well-written malware comes with a packer and is heavily encrypted, we will need to get to the unpacked executable using a debugger. There are some commonly used API calls by malwares such as VirtualAlloc & VirtualProtect, which we can also use as breakpoints for our analysis. The below API calls can be useful in unpacking the sample:<br>
1) VirtualAlloc<br>
2) VirtualProtect<br>
3) CreateProcessInternalW<br>
4) WriteProcessMemory<br>
5) NtResumeThread<br>
6) IsDebuggerPresent (interference of analysis)<br>

Additionally, one might need to observe the 6 general purpose registers that hold information, which can crucial through the analysis.<br>
1) EAX: Used for arithmetic and logical operations. Stores function return values. This is important as usually the loaders will allocate memory for the unpacked sample using VirtualAlloc. On a VirtualAlloc breakpoint, we can then hit "execute till return" where we will execute till the return statement of the function VirtualAlloc. Since VirtualAlloc returns the address of the empty allocated memory space, EAX will then be the register that stores this address (as EAX stores function return values :)). This also us to see if anything is written in the memory space on subsequent runs. If lucky, you might find yourself an unpacked executable in the memory space!<br>
2) EBX: Base pointer, or for storing memory addresses<br>
3) ECX: Loop counter, or holds function arguments<br>
4) EDX: I/O Operations, or holds temporary data (EAX's backup)<br>
5) ESI: Used as a source pointer for string operations and array indexing<br>
6) EDI: Destination pointer for string operations and array indexing<br>
 